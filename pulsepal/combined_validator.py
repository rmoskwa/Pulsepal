"""
Combined validator for PulsePal that ensures proper ordering and state management.
"""

import logging
import re
from typing import Optional, Set, Tuple

from pydantic_ai import ModelRetry, RunContext

from .dependencies import PulsePalDependencies
from .validation_state import get_validation_state_manager
from .output_validator import (
    extract_pulseq_functions,
    validate_pulseq_function,
    build_validation_error_message,
    MAX_VALIDATION_RETRIES,
)

logger = logging.getLogger(__name__)

# Source tags
GENERATED_TAG = "---Generated by Gemini---"
RETRIEVED_TAG = "---Retrieved example---"

# Safer regex patterns to avoid ReDoS
CODE_BLOCK_PATTERN = re.compile(
    r"```(?:matlab|python|m)?\n"
    r"((?:---Generated by Gemini---|---Retrieved example---)?\n?"
    r"(?:[^`]|`(?!``))*?)"
    r"```",
    re.DOTALL,
)

# Pattern to extract Pulseq functions (simplified for safety)
PULSEQ_FUNCTION_PATTERN = re.compile(r"\b(mr|seq|tra|eve|opt)\.([A-Za-z]\w{0,50})\b")


def extract_code_blocks_safely(
    text: str, max_length: int = 100000
) -> list[Tuple[str, Optional[str]]]:
    """
    Safely extract code blocks with their tags.

    Args:
        text: The text to extract from
        max_length: Maximum text length to process (prevents ReDoS)

    Returns:
        List of (code_content, tag_type) tuples
    """
    # Limit input length to prevent ReDoS
    if len(text) > max_length:
        logger.warning(f"Text too long ({len(text)} chars), truncating to {max_length}")
        text = text[:max_length]

    blocks = []

    for match in CODE_BLOCK_PATTERN.finditer(text):
        content = match.group(1)

        # Determine tag type
        tag_type = None
        clean_content = content

        if content.startswith(GENERATED_TAG):
            tag_type = "generated"
            clean_content = content[len(GENERATED_TAG) :].lstrip("\n")
        elif content.startswith(RETRIEVED_TAG):
            tag_type = "retrieved"
            clean_content = content[len(RETRIEVED_TAG) :].lstrip("\n")

        blocks.append((clean_content, tag_type))

    return blocks


def extract_custom_functions(code: str) -> Set[str]:
    """
    Extract Pulseq function calls from code.

    Args:
        code: The code to extract from

    Returns:
        Set of function calls
    """
    functions = set()

    # Limit search to first 10000 chars for safety
    code_to_search = code[:10000] if len(code) > 10000 else code

    for line in code_to_search.split("\n"):
        # Skip comments
        if line.strip().startswith(("%", "#", "//")):
            continue

        for match in PULSEQ_FUNCTION_PATTERN.finditer(line):
            functions.add(match.group(0))

    return functions


def strip_tags_from_text(text: str) -> str:
    """
    Remove source tags from code blocks.

    Args:
        text: Text with tagged code blocks

    Returns:
        Text with tags removed
    """

    def replace_block(match):
        content = match.group(1)

        # Remove tags if present
        if content.startswith(GENERATED_TAG):
            content = content[len(GENERATED_TAG) :].lstrip("\n")
        elif content.startswith(RETRIEVED_TAG):
            content = content[len(RETRIEVED_TAG) :].lstrip("\n")

        # Get language specifier
        lang_match = match.group(0).split("\n")[0].replace("```", "")

        return f"```{lang_match}\n{content}```"

    return CODE_BLOCK_PATTERN.sub(replace_block, text)


async def combined_output_validator(
    ctx: RunContext[PulsePalDependencies], output: str
) -> str:
    """
    Combined validator that handles both tag validation and function validation.

    This ensures proper ordering and state management without race conditions.

    Args:
        ctx: Run context with dependencies
        output: The agent's response

    Returns:
        Validated and cleaned output

    Raises:
        ModelRetry: If validation fails
    """
    # Get session ID
    session_id = (
        ctx.deps.conversation_context.session_id
        if ctx.deps.conversation_context
        else "default"
    )

    # Get or create validation state for this session
    state_manager = get_validation_state_manager()
    validation_state = await state_manager.get_or_create_state(session_id)

    # Phase 1: Tag validation and extraction
    blocks = extract_code_blocks_safely(output)

    if not blocks:
        # No code blocks, nothing to validate
        return output

    # Check for untagged blocks
    untagged_blocks = []
    retrieved_functions = set()
    has_generated_code = False

    for code_content, tag_type in blocks:
        if tag_type is None:
            # Found untagged block
            preview = (
                code_content[:100] + "..." if len(code_content) > 100 else code_content
            )
            untagged_blocks.append(preview)
        elif tag_type == "retrieved":
            # Extract functions from retrieved examples
            functions = extract_custom_functions(code_content)
            retrieved_functions.update(functions)
        elif tag_type == "generated":
            has_generated_code = True

    # If there are untagged blocks, request tagging (with retry limit)
    if untagged_blocks:
        # Check tag validation retry count
        tag_retry_count = getattr(ctx, "tag_retry_count", 0)
        if tag_retry_count >= MAX_VALIDATION_RETRIES:
            logger.warning(
                f"Exceeded tag validation retries ({MAX_VALIDATION_RETRIES}) for session {session_id}"
            )
            # Continue despite untagged blocks - let Phase 2 validate functions
            logger.info("Proceeding to function validation despite untagged blocks")
        else:
            logger.warning(
                f"Found {len(untagged_blocks)} untagged code blocks (retry {tag_retry_count + 1}/{MAX_VALIDATION_RETRIES})"
            )

            error_message = (
                "⚠️ **Code blocks must be tagged with their source**\n\n"
                "Please add one of these tags at the beginning of each code block:\n"
                f"• `{GENERATED_TAG}` - For code you created\n"
                f"• `{RETRIEVED_TAG}` - For code from search results\n\n"
                "Example:\n"
                "```matlab\n"
                f"{GENERATED_TAG}\n"
                "% Your code here\n"
                "```\n\n"
                f"Found {len(untagged_blocks)} untagged code block(s).\n"
                f"*Tag validation retry {tag_retry_count + 1} of {MAX_VALIDATION_RETRIES}*"
            )

            # Increment tag retry count for next attempt
            ctx.tag_retry_count = tag_retry_count + 1

            raise ModelRetry(error_message)

    # Phase 1 successful - reset tag retry counter
    if hasattr(ctx, "tag_retry_count"):
        ctx.tag_retry_count = 0
        logger.debug(f"Reset tag retry counter for session {session_id}")

    # Update validation state
    if retrieved_functions:
        validation_state.add_to_whitelist(retrieved_functions)
        logger.info(f"Added {len(retrieved_functions)} functions to whitelist")

    # Strip tags from output
    output = strip_tags_from_text(output)

    # Phase 2: Function validation (only for generated code)
    if not has_generated_code:
        logger.info("All code is retrieved examples - skipping function validation")
        # Reset function retry counter even when skipping validation
        if hasattr(ctx, "func_retry_count"):
            ctx.func_retry_count = 0
        return output

    # Extract all Pulseq functions for validation
    functions = extract_pulseq_functions(output)

    if not functions:
        # No functions to validate - reset function retry counter
        if hasattr(ctx, "func_retry_count"):
            ctx.func_retry_count = 0
        return output

    # Get whitelist from validation state
    whitelist = validation_state.get_whitelist()

    # Validate each function
    invalid_functions = []
    for func_call, context, line_num in functions:
        validation = validate_pulseq_function(func_call, whitelist)
        if not validation["is_valid"]:
            invalid_functions.append((func_call, validation))
            logger.info(f"Invalid function: {func_call} at line {line_num}")

    if invalid_functions:
        # Check function validation retry count (separate from tag retry count)
        func_retry_count = getattr(ctx, "func_retry_count", 0)
        if func_retry_count >= MAX_VALIDATION_RETRIES:
            logger.warning(
                f"Exceeded function validation retries ({MAX_VALIDATION_RETRIES}) for session {session_id}"
            )
            return (
                output + "\n\n*Note: Some functions may not be valid. Please verify.*"
            )

        logger.info(
            f"Invalid functions found (retry {func_retry_count + 1}/{MAX_VALIDATION_RETRIES})"
        )

        # Build error message (this already includes retry count in the message)
        error_message = build_validation_error_message(invalid_functions, session_id)

        # Increment function retry count for next attempt
        ctx.func_retry_count = func_retry_count + 1

        raise ModelRetry(error_message)

    # Phase 2 successful - reset function retry counter
    if hasattr(ctx, "func_retry_count"):
        ctx.func_retry_count = 0
        logger.debug(f"Reset function retry counter for session {session_id}")

    return output
