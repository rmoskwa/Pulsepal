"""
Tag validator for PulsePal agent responses.
Detects and processes code block source tags to determine validation flow.
"""

import asyncio
import logging
import re
from typing import Dict, Optional, Set, Tuple

from pydantic_ai import ModelRetry, RunContext

from .dependencies import PulsePalDependencies

logger = logging.getLogger(__name__)

# Source tags that indicate code origin
GENERATED_TAG = "---Generated by Gemini---"
RETRIEVED_TAG = "---Retrieved example---"

# Pattern to detect code blocks with potential tags
CODE_BLOCK_WITH_TAG_PATTERN = re.compile(
    r"```(?:matlab|python|m)?\n((?:---Generated by Gemini---|---Retrieved example---)?\n?.*?)```",
    re.DOTALL,
)

# Pattern to detect any code block
CODE_BLOCK_PATTERN = re.compile(r"```(?:matlab|python|m)?\n(.*?)```", re.DOTALL)

# Session-specific custom function whitelists
_custom_function_whitelists: Dict[str, Set[str]] = {}
_whitelist_lock = asyncio.Lock()

# Tracking if function validation should be skipped for current response
_skip_function_validation: Dict[str, bool] = {}
_skip_lock = asyncio.Lock()


def extract_code_blocks_with_tags(
    text: str,
) -> list[Tuple[str, Optional[str], int, int]]:
    """
    Extract code blocks and their source tags from text.

    Args:
        text: The complete response text

    Returns:
        List of tuples: (code_content, tag_type, start_pos, end_pos)
        tag_type can be "generated", "retrieved", or None
    """
    blocks = []

    for match in CODE_BLOCK_WITH_TAG_PATTERN.finditer(text):
        content = match.group(1)
        start_pos = match.start()
        end_pos = match.end()

        # Check for tags at the beginning of the code block
        tag_type = None
        if content.startswith(GENERATED_TAG):
            tag_type = "generated"
            # Remove the tag from content
            content = content[len(GENERATED_TAG) :].lstrip("\n")
        elif content.startswith(RETRIEVED_TAG):
            tag_type = "retrieved"
            # Remove the tag from content
            content = content[len(RETRIEVED_TAG) :].lstrip("\n")

        blocks.append((content, tag_type, start_pos, end_pos))

    return blocks


def strip_tags_from_output(text: str) -> str:
    """
    Remove source tags from code blocks in the output.

    Args:
        text: The complete response text with tags

    Returns:
        The text with tags removed from code blocks
    """

    # Replace code blocks that have tags
    def replace_block(match):
        lang = match.group(1) or ""  # Language specifier (group 1)
        content = match.group(2)  # Code content (group 2)

        # Remove tags if present
        if content.startswith(GENERATED_TAG):
            content = content[len(GENERATED_TAG) :].lstrip("\n")
        elif content.startswith(RETRIEVED_TAG):
            content = content[len(RETRIEVED_TAG) :].lstrip("\n")

        # Reconstruct code block without tag
        return f"```{lang}\n{content}```"

    # Pattern that captures the language specifier and content
    pattern = re.compile(r"```(matlab|python|m)?\n(.*?)```", re.DOTALL)
    return pattern.sub(replace_block, text)


def extract_pulseq_functions_from_code(code: str) -> Set[str]:
    """
    Extract Pulseq function calls from a code block.

    Args:
        code: The code content

    Returns:
        Set of function calls (e.g., {"mr.makeAdc", "seq.write"})
    """
    functions = set()

    # Patterns for Pulseq functions
    patterns = [
        re.compile(r"\b(mr|seq|tra|eve|opt)\.([A-Za-z]\w*)"),
        re.compile(r"\b(mr)\.aux\.([A-Za-z]\w*)"),
        re.compile(r"\b(mr)\.aux\.quat\.([A-Za-z]\w*)"),
        re.compile(r"\b(mr)\.Siemens\.([A-Za-z]\w*)"),
        re.compile(r"\b(mrMusic)\.([A-Za-z]\w*)"),
    ]

    for line in code.split("\n"):
        # Skip comments
        if line.strip().startswith("%") or line.strip().startswith("#"):
            continue

        for pattern in patterns:
            matches = pattern.finditer(line)
            for match in matches:
                functions.add(match.group(0))

    return functions


async def add_to_session_whitelist(session_id: str, functions: Set[str]):
    """
    Add custom functions to the session-specific whitelist.

    Args:
        session_id: The session identifier
        functions: Set of function calls to whitelist
    """
    async with _whitelist_lock:
        if session_id not in _custom_function_whitelists:
            _custom_function_whitelists[session_id] = set()

        _custom_function_whitelists[session_id].update(functions)
        logger.info(
            f"Added {len(functions)} custom functions to whitelist for session {session_id}"
        )
        logger.debug(f"Whitelisted functions: {functions}")


async def get_session_whitelist(session_id: str) -> Set[str]:
    """
    Get the custom function whitelist for a session.

    Args:
        session_id: The session identifier

    Returns:
        Set of whitelisted function calls
    """
    async with _whitelist_lock:
        return _custom_function_whitelists.get(session_id, set()).copy()


async def clear_session_whitelist(session_id: str):
    """
    Clear the whitelist for a session.

    Args:
        session_id: The session identifier
    """
    async with _whitelist_lock:
        if session_id in _custom_function_whitelists:
            del _custom_function_whitelists[session_id]
            logger.debug(f"Cleared whitelist for session {session_id}")


async def set_skip_function_validation(session_id: str, skip: bool):
    """
    Set whether to skip function validation for the current response.

    Args:
        session_id: The session identifier
        skip: Whether to skip validation
    """
    async with _skip_lock:
        _skip_function_validation[session_id] = skip


async def should_skip_function_validation(session_id: str) -> bool:
    """
    Check if function validation should be skipped for current response.

    Args:
        session_id: The session identifier

    Returns:
        True if validation should be skipped
    """
    async with _skip_lock:
        return _skip_function_validation.get(session_id, False)


async def validate_code_tags(ctx: RunContext[PulsePalDependencies], output: str) -> str:
    """
    Tag validator for PulsePal agent responses.
    Detects code block tags and manages validation flow.

    This validator should run BEFORE the function validator.

    Args:
        ctx: Run context with dependencies
        output: The agent's response text

    Returns:
        The output with tags stripped

    Raises:
        ModelRetry: If code blocks are found without proper tags
    """
    # Get session ID
    session_id = (
        ctx.deps.conversation_context.session_id
        if ctx.deps.conversation_context
        else "default"
    )

    # Extract code blocks with their tags
    blocks = extract_code_blocks_with_tags(output)

    if not blocks:
        # No code blocks, nothing to validate
        await set_skip_function_validation(session_id, False)
        return output

    # Check for untagged code blocks
    untagged_blocks = []
    retrieved_functions = set()
    has_generated_code = False

    for code_content, tag_type, start_pos, end_pos in blocks:
        if tag_type is None:
            # Found untagged code block
            preview = (
                code_content[:100] + "..." if len(code_content) > 100 else code_content
            )
            untagged_blocks.append(preview)
        elif tag_type == "retrieved":
            # Extract functions from retrieved examples for whitelisting
            functions = extract_pulseq_functions_from_code(code_content)
            retrieved_functions.update(functions)
        elif tag_type == "generated":
            has_generated_code = True

    # If there are untagged blocks, request tagging
    if untagged_blocks:
        logger.warning(f"Found {len(untagged_blocks)} untagged code blocks in output")

        error_message = (
            "⚠️ **Code blocks must be tagged with their source**\n\n"
            "Please add one of these tags at the beginning of each code block:\n"
            f"• `{GENERATED_TAG}` - For code you created\n"
            f"• `{RETRIEVED_TAG}` - For code from search results or examples\n\n"
            "Example:\n"
            "```matlab\n"
            f"{GENERATED_TAG}\n"
            "% Your code here\n"
            "adc = mr.makeAdc(...);\n"
            "```\n\n"
            f"Found {len(untagged_blocks)} untagged code block(s). "
            "Please regenerate your response with proper tags."
        )

        raise ModelRetry(error_message)

    # Add retrieved functions to session whitelist
    if retrieved_functions:
        await add_to_session_whitelist(session_id, retrieved_functions)
        logger.info(
            f"Whitelisted {len(retrieved_functions)} functions from retrieved examples"
        )

    # Determine if function validation should be skipped
    # Skip if ALL code blocks are retrieved examples (no generated code)
    skip_validation = len(blocks) > 0 and not has_generated_code
    await set_skip_function_validation(session_id, skip_validation)

    if skip_validation:
        logger.info(
            "All code blocks are retrieved examples - skipping function validation"
        )
    else:
        logger.info(
            "Response contains generated code - function validation will proceed"
        )

    # Strip tags from output before returning
    cleaned_output = strip_tags_from_output(output)

    return cleaned_output
